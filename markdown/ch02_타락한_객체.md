#Task List
- [ ] $5 + 10CHF = $10 (환율이 2:1일 경우)
- [x] ~~$5 X 2 = $10~~
- [ ] amount를 private으로 만들기
- [x] ~~Dollar 부작용(side effect)?~~
- [ ] Money 반올림?

#DID it!
- 설계상의 결함(Dollar 부작용)을 그 결함으로 인해 실패하는 테스트로 변환했다.
- 스텁 구현으로 빠르게 컴파일을 통과하도록 만들었다.
- 올바르다고 생각하는 코드를 입력하여 테스트를 통과했다.

#TDD 주기
1. 작은 테스트를 하나 추가한다.
    - 마음 속에 있는 오퍼레이션(객체 간 전달할 __메시지__)이 코드에 어떤 식으로 나타나길 원하는지 생각해보라.
    - 이야기를 써내려가는 것이다.
    - 원하는 인터페이스(__메시지__)를 개발하라.
    - 올바른 답을 얻기 위해 필요한 이야기의 모든 요소를 포함시켜라.
2. 실행 가능하게 만든다.
    1. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
    2. 조금 수정한다.
        - 깔끔하고 단순한 해법이 명백히 보인다면 그것을 입력하라.
            - 구현하는데 몇 분 정도 걸릴 것 같으면 일단 적어 놓고 초록 막대를 보는데 집중하자.
        - 소프트웨어 정의를 벗어나는 죄악을 저질러도 좋다. (예: 하드코딩)
    3. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
        - 빨리 초록 막대를 보는 것이다. (3가지 전략)
            - 가짜로 구현하기 : 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
            - 명백한 구현 사용하기 : 실제 구현을 입력한다.
            - 삼각측량(triangulation)
3. 올바르게 만든다.
    1. 중복을 제거하기 위해 리팩토링을 한다. 
        - Once and only once. : 필요한 것을 하되(once) 단 한 번만(only once) 하라는 뜻의 익스트림 프로그래밍 실천사항과 통한다.)
        - 직전에 저질렀던 죄악을 수습하자.
        - 좁고 올곧은 소프트웨어 정의(software righteousness)의 길로 되돌아와서 중복을 제거하고 초록 막대로 되돌리자.
   
#Note it!
- 우리의 목적은 작동하는 깔끔한 코드를 얻는 것이다. (론 제프리즈)
    - 나누어서 정복하자 (divide and conquer)
    - '작동하는'을 먼저 해결하고, '깔끔한 코드'는 작동 후에 해결한다.
        - 반대로 접근한다면 배운 것들을 설계에 반영하느라 허둥거리는 '아키텍처 주도 개발(architecture-driven development)'과 정반대이다.